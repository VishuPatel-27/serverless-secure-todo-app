# This AWS Serverless Application Model (SAM) template defines serverless infrastructure.
# It includes API Gateway endpoints, Lambda functions, DynamoDB table, Cognito User Pool,
# CloudFront distribution and an S3 bucket for the static frontend.
AWSTemplateFormatVersion: '2010-09-09'
# This below declaration is required for SAM templates files (this declaration identifies an AWS CloudFormation template as a SAM template)
Transform: AWS::Serverless-2016-10-31

Description: A secure serverless To-Do application with Node.js and Cognito authentication.

# This template deploys a serverless To-Do application with the following components:
# API Gateway for RESTful endpoints
# Lambda functions for business logic
# DynamoDB for data storage
# Cognito User Pool for user authentication
# S3 bucket for hosting the static frontend
# CloudFront distribution for content delivery

# This parameter section allows customization of the deployment.
# You can specify the S3 bucket name for the frontend and the API Gateway URL.
Parameters:
  # Parameter for the S3 bucket name where the frontend will be hosted.
  FrontendBucketName:
    Type: String
    Description: Name of the S3 bucket to host the static frontend. Must be globally unique.
    # Default value is provided, but we can change it to our desired bucket name
    Default: serverless-secure-todo-app-frontend

Globals:
  Function:
    # All Lambda functions will use Node.js 20.x runtime.
    Runtime: nodejs20.x
    # Set a default timeout for Lambda functions. Adjust as needed.
    Timeout: 10
    # # Common environment variables for all functions (e.g., DynamoDB table name)
    # Environment:
    #   TODOS_TABLE_NAME: !Ref TodosTable

Resources:
  # --- Amazon Cognito User Pool for Authentication ---
  # This User Pool manages user registration, login, and identity.
  CognitoUserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: ServerlessTodoUserPool
      # Configure attributes for user sign-up. Email is common.
      UsernameAttributes:
        - email
      AutoVerifiedAttributes:
        - email # Automatically verify email addresses upon registration
      # Policies define the security requirements for user passwords.
      # Here, we enforce a strong password policy.
      # You can adjust these policies based on your security requirements.
      Policies:
        PasswordPolicy:
          MinimumLength: 8
          RequireLowercase: true
          RequireNumbers: true
          RequireSymbols: false
          RequireUppercase: true
      # Define the schema for user attributes.
      # This schema defines the attributes that users must provide when signing up.
      # Here, we require an email address as a unique identifier.
      # You can add more attributes as needed (e.g., phone number, name).
      Schema:
        - Name: email
          AttributeDataType: String
          Mutable: true
          Required: true
      MfaConfiguration: 'OFF' # Can be set to OPTIONAL or REQUIRED for MFA

  # --- AWS WAF Web ACL for CloudFront Distribution ---
  # This Web ACL provides protection against common web exploits.
  # It is associated with the CloudFront distribution to protect the static frontend.
  WebACL:
    Type: AWS::WAFv2::WebACL
    Properties:
      Name: ServerlessTodoWebACL
      Scope: CLOUDFRONT # This Web ACL is for CloudFront distribution
      DefaultAction:
        Allow: {} # Default action is to allow requests
      VisibilityConfig:
        SampledRequestsEnabled: true # Enable sampled requests for monitoring
        CloudWatchMetricsEnabled: true # Enable CloudWatch metrics for visibility
        MetricName: ServerlessTodoWebACL # Metric name for CloudWatch
      Rules:
          # This rule protect against the malicious actors by filtering out the request with know bad inputs and
          # attack patterns like log4j
        - Name: AWS-AWSManagedRulesKnownBadInputsRuleSet
          Priority: 1
          Statement:
            ManagedRuleGroupStatement:
              VendorName: AWS
              Name: AWSManagedRulesKnownBadInputsRuleSet
          OverrideAction:
            None: {}
          VisibilityConfig:
            CloudWatchMetricsEnabled: true # Enable CloudWatch metrics for this rule
            MetricName: AWSManagedRulesKnownBadInputsRuleSet
            SampledRequestsEnabled: true # Enable sampled requests for this rule.
        - Name: AWS-AWSManagedRulesCommonRuleSet
          Priority: 0 # Priority of the rule in the Web ACL
          OverrideAction:
            None: {} # No override action, use the default action
          Statement:
            ManagedRuleGroupStatement:
              Name: AWSManagedRulesCommonRuleSet # Use AWS managed rules for common web exploits
              VendorName: AWS # Vendor name for the managed rule group
          VisibilityConfig:
            SampledRequestsEnabled: true # Enable sampled requests for this rule
            CloudWatchMetricsEnabled: true # Enable CloudWatch metrics for this rule
            MetricName: AWSManagedRulesCommonRuleSet # Metric name for CloudWatch
  # AWS KMS key for dynamodb encryption
  # This key is used to encrypt the DynamoDB table data at rest.
  KMSKeyForDBandLogs:
    Type: AWS::KMS::Key
    Properties:
      Description: KMS key used for encrypting DynamoDB table, CloudWatch logs, and Lambda environment variables.
      EnableKeyRotation: true
      KeyUsage: ENCRYPT_DECRYPT # Key usage for encryption and decryption
      KeyPolicy:
        Version: '2012-10-17'
        Statement:
          # Allow account root full control of the key (required for management)
          - Sid: AllowAccountRootAccess
            Effect: Allow
            Principal:
              AWS: !Sub arn:aws:iam::${AWS::AccountId}:root
            Action: "kms:*"
            Resource: "*"

          # Allow lambda functions to use the key for encryption and decryption of dynamodb table and env variables
          - Sid: AllowLambdaUseOfKey
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action:
              - kms:Encrypt
              - kms:Decrypt
              - kms:ReEncrypt*
              - kms:GenerateDataKey*
              - kms:DescribeKey
            Resource: "*"

          # Allow DynamoDB to use the key for encryption and decryption
          - Sid: AllowDynamoDBUsage
            Effect: Allow
            Principal:
              Service: dynamodb.amazonaws.com
            Action:
              - kms:Encrypt
              - kms:Decrypt
              - kms:ReEncrypt*
              - kms:GenerateDataKey*
              - kms:DescribeKey
            Resource: "*"
    
  # A client application for the Cognito User Pool.
  # This is what your frontend will use to interact with Cognito.
  CognitoUserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      ClientName: ServerlessTodoAppClient
      UserPoolId: !Ref CognitoUserPool
      # Define allowed OAuth flows for authentication.
      # You might configure different flows based on your frontend needs (e.g., Implicit Grant for SPAs).
      # SupportedIdentityProviders defines which identity providers can be used.
      # Here, we only use Cognito as the identity provider. we can add others like Google, Facebook, etc.
      SupportedIdentityProviders:
        - COGNITO
      # Allowed OAuth flows and scopes for the client.
      AllowedOAuthFlowsUserPoolClient: true
      # OAuth flows define how the client can authenticate users.
      # 'code' is used for server-side applications, 'implicit' for single-page applications.
      # AllowedOAuthScopes defines the permissions the client can request.
      # Common scopes include 'email', 'openid', and 'profile'.
      AllowedOAuthFlows:
        - implicit
        - code
      AllowedOAuthScopes:
        - email
        - openid
        - profile
      # Callback URLs are where Cognito redirects after successful authentication.
      # NOW USING CloudFront distribution URL with HTTPS.
      CallbackURLs:
        - http://localhost:8080/ # For local development
        - !Join
          - ''
          - - https://
            - !GetAtt CloudFrontDistribution.DomainName
            - /
          # HTTPS via CloudFront
      LogoutURLs:
        - http://localhost:8080/ # For local development
        - !Join
          - ''
          - - https://
            - !GetAtt CloudFrontDistribution.DomainName
            - /
          # HTTPS via CloudFront
      ExplicitAuthFlows:
        # These are the authentication flows that the client will support.
        # This allows the client to authenticate users using different methods.
        # For eample, ALLOW_USER_SRP_AUTH allows users to log in using the Secure Remote Password protocol, 
        # Which is a secure way to authenticate users without sending their password in plaintext.
        - ALLOW_ADMIN_USER_PASSWORD_AUTH
        - ALLOW_USER_PASSWORD_AUTH
        - ALLOW_REFRESH_TOKEN_AUTH
        - ALLOW_USER_SRP_AUTH

  # --- Amazon DynamoDB Table for To-Do Items ---
  TodosTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: ServerlessTodoItems
      # Define the primary key for your table.
      # 'userId' as partition key allows efficient retrieval of all todos for a specific user.
      # 'todoId' as sort key allows unique identification of each todo for a user.
      # userId is a unique identifier for each user, and todoId is a unique identifier for each to-do item.
      AttributeDefinitions:
        - AttributeName: userId
          AttributeType: S
        - AttributeName: todoId
          AttributeType: S
      # Define the key schema for the table.
      # The key schema defines how the data is organized in the table.
      # Here, we use a composite key with userId as the partition key and todoId as the sort key.
      KeySchema:
        - AttributeName: userId
          # This is the partition key for the table
          KeyType: HASH
        - AttributeName: todoId
          # This allows us to store multiple todos for each user
          KeyType: RANGE
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true # Enables point-in-time recovery for the table
      SSESpecification:
        SSEEnabled: true # Enable server-side encryption for the table
        SSEType: KMS
        KMSMasterKeyId: !GetAtt KMSKeyForDBandLogs.Arn  # Use the KMS key defined above for encryption
      # Set billing mode to PAY_PER_REQUEST for cost optimization in serverless apps.
      # This scales automatically and you pay only for reads/writes.
      BillingMode: PAY_PER_REQUEST

  # --- API Gateway Definition ---
  # This explicitly defines your API Gateway and its authorizers.
  TodoApi:
    #checkov:skip=CKV_AWS_73: This API Gateway dosen't have x-ray tracing enabled, but it is not a security risk in this context.
    #checkov:skip=CKV_AWS_76: Logging is not enabled for this API Gateway, but it is not a security risk in this context.
    Type: AWS::Serverless::Api
    Properties:
      StageName: Prod
      Auth:
        DefaultAuthorizer: CognitoUserPoolAuthorizer
        # Disable default authorizer for CORS preflight
        AddDefaultAuthorizerToCorsPreflight: false 
        # Define the Cognito User Pool authorizer for API Gateway.
        Authorizers:
          CognitoUserPoolAuthorizer:
            UserPoolArn: !GetAtt CognitoUserPool.Arn
      DefinitionBody:
        swagger: 2
        info:
          title: ServerlessTodoAPI
          version: 1
        paths:
          /todos:
            get:
              consumes:
                - application/json
              produces:
                - application/json
              x-amazon-apigateway-integration:
                uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${GetTodosFunction.Arn}/invocations
                httpMethod: POST
                type: aws_proxy
            post:
              consumes:
                - application/json
              produces:
                - application/json
              x-amazon-apigateway-integration:
                uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${CreateTodoFunction.Arn}/invocations
                httpMethod: POST
                type: aws_proxy
            options:
              consumes:
                - application/json
              produces:
                - application/json
              x-amazon-apigateway-integration:
                type: mock
                requestTemplates:
                  application/json: '{"statusCode": 200}'
                responses:
                  default:
                    statusCode: 200
                    responseParameters:
                      method.response.header.Access-Control-Allow-Headers: '''Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'''
                      method.response.header.Access-Control-Allow-Methods: '''OPTIONS,GET,POST'''
                      method.response.header.Access-Control-Allow-Origin: '''*'''
                    responseTemplates:
                      application/json: '{}'
              responses:
                '200':
                  description: 200 response
                  headers:
                    Access-Control-Allow-Headers:
                      type: string
                    Access-Control-Allow-Methods:
                      type: string
                    Access-Control-Allow-Origin:
                      type: string
          /todos/{id}:
            put:
              consumes:
                - application/json
              produces:
                - application/json
              x-amazon-apigateway-integration:
                uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${UpdateTodoFunction.Arn}/invocations
                httpMethod: POST
                type: aws_proxy
            delete:
              consumes:
                - application/json
              produces:
                - application/json
              x-amazon-apigateway-integration:
                uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${DeleteTodoFunction.Arn}/invocations
                httpMethod: POST
                type: aws_proxy
            options:
              consumes:
                - application/json
              produces:
                - application/json
              x-amazon-apigateway-integration:
                type: mock
                requestTemplates:
                  application/json: '{"statusCode": 200}'
                responses:
                  default:
                    statusCode: 200
                    responseParameters:
                      method.response.header.Access-Control-Allow-Headers: '''Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'''
                      method.response.header.Access-Control-Allow-Methods: '''OPTIONS,PUT,DELETE'''
                      method.response.header.Access-Control-Allow-Origin: '''*'''
                    responseTemplates:
                      application/json: '{}'
              responses:
                '200':
                  description: 200 response
                  headers:
                    Access-Control-Allow-Headers:
                      type: string
                    Access-Control-Allow-Methods:
                      type: string
                    Access-Control-Allow-Origin:
                      type: string
        # checkov:skip=CKV_AWS_120: Caching not applicable to all routes; handled selectively for performance.
        x-amazon-apigateway-stage:
          cacheClusterEnabled: true
          cacheClusterSize: '0.5' # Smallest cache size for cost efficiency
          methodSettings:
            - resourcePath: "/todos"
              httpMethod: GET, POST, OPTIONS
              cachingEnabled: true
              cacheTtlInSeconds: 300 # Cache for 5 minutes

  # --- Explicit IAM Role for Lambda Functions ---
  # Define a single IAM Role that all your Lambda functions will use.
  # This role grants permissions to write logs to CloudWatch and perform CRUD on DynamoDB.
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com # Allows Lambda service to assume this role
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole # Provides basic CloudWatch logging permissions
      Policies:
        - PolicyName: DynamoDBAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:BatchGetItem
                  - dynamodb:BatchWriteItem
                Resource: !GetAtt TodosTable.Arn # Grants access specifically to your TodosTable ARN
        - PolicyName: KMSKeyAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - kms:Encrypt
                  - kms:Decrypt
                  - kms:ReEncrypt*
                  - kms:GenerateDataKey*
                  - kms:DescribeKey
                Resource: !GetAtt KMSKeyForDBandLogs.Arn # Grants access to the KMS key for encryption/decryption
        - PolicyName: CloudWatchLogsPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
                - Effect: Allow
                  Action:
                    - logs:CreateLogGroup
                    - logs:CreateLogStream
                    - logs:PutLogEvents
                  Resource: !Sub arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/* # Grants access to all Lambda log groups

  # Lambda function to create a new to-do item.
  CreateTodoFunction:
    Type: AWS::Serverless::Function
    Properties:
      # checkov:skip=CKV_AWS_115: This Lambda function has not required function-level concurrent execution limit
      # checkov:skip=CKV_AWS_116: This Lambda function has not been configure with the DLQ,
      # but it is not a security risk in this context.
      # checkov:skip=CKV_AWS_117: This Lambda function has not been configure with the VPC,
      # becuase it does not require VPC access for this use case.
      #checkov:skip=CKV_AWS_158: Logs encryption with CMK not required for this project
      CodeUri: ./ # points to the source code file
      Handler: ./todos.createTodoHandler # points to todos.js file, createTodoHandler function
      Runtime: nodejs20.x # Explicitly set runtime here as Globals.Function is overridden by Role property
      Timeout: 10 # Explicitly set timeout here
      Environment:
        Variables:
          TODOS_TABLE_NAME: !Ref TodosTable
          kmsKeyId: !Ref KMSKeyForDBandLogs # Use the KMS key for encryption
      KmsKeyArn: !GetAtt KMSKeyForDBandLogs.Arn # Use the KMS key for encryption
      Role: !GetAtt LambdaExecutionRole.Arn # Assign the explicit IAM role      
      # Define events that trigger this Lambda function (API Gateway endpoint).
      Events:
        CreateTodoApi:
          Type: Api
          Properties:
            Path: /todos
            Method: post
            RestApiId: !Ref TodoApi # Link to the explicitly defined API Gateway

  # Lambda function to get all to-do items for the authenticated user.
  GetTodosFunction:
    Type: AWS::Serverless::Function
    Properties:
      # checkov:skip=CKV_AWS_115: This Lambda function has not required function-level concurrent execution limit
      # checkov:skip=CKV_AWS_116: This Lambda function has not been configure with the DLQ,
      # but it is not a security risk in this context.
      # checkov:skip=CKV_AWS_117: This Lambda function has not been configure with the VPC,
      # becuase it does not require VPC access for this use case.
      #checkov:skip=CKV_AWS_158: Logs encryption with CMK not required for this project
      CodeUri: ./
      Handler: ./todos.getTodosHandler
      Runtime: nodejs20.x
      Timeout: 10
      Environment:
        Variables:
          TODOS_TABLE_NAME: !Ref TodosTable
      KmsKeyArn: !GetAtt KMSKeyForDBandLogs.Arn # Use the KMS key for encryption
      Role: !GetAtt LambdaExecutionRole.Arn # Assign the explicit IAM role
      Events:
        GetTodosApi:
          Type: Api
          Properties:
            Path: /todos
            Method: get
            RestApiId: !Ref TodoApi

  # Lambda function to update an existing to-do item.
  UpdateTodoFunction:
    Type: AWS::Serverless::Function
    Properties:
      # checkov:skip=CKV_AWS_115: This Lambda function has not required function-level concurrent execution limit
      # checkov:skip=CKV_AWS_116: This Lambda function has not been configure with the DLQ,
      # but it is not a security risk in this context.
      # checkov:skip=CKV_AWS_117: This Lambda function has not been configure with the VPC,
      # becuase it does not require VPC access for this use case.
      #checkov:skip=CKV_AWS_158: Logs encryption with CMK not required for this project
      CodeUri: ./
      Handler: ./todos.updateTodoHandler
      Runtime: nodejs20.x
      Timeout: 10
      Environment:
        Variables:
          TODOS_TABLE_NAME: !Ref TodosTable
      KmsKeyArn: !GetAtt KMSKeyForDBandLogs.Arn # Use the KMS key for encryption
      Role: !GetAtt LambdaExecutionRole.Arn # Assign the explicit IAM role
      Events:
        UpdateTodoApi:
          Type: Api
          Properties:
            Path: /todos/{id}
            Method: put
            RestApiId: !Ref TodoApi

  # Lambda function to delete a to-do item.
  DeleteTodoFunction:
    # checkov:skip=CKV_AWS_115: This Lambda function has not required function-level concurrent execution limit  
    Type: AWS::Serverless::Function
    Properties:
      # checkov:skip=CKV_AWS_116: This Lambda function has not been configure with the DLQ,
      # but it is not a security risk in this context.
      # checkov:skip=CKV_AWS_117: This Lambda function has not been configure with the VPC,
      # becuase it does not require VPC access for this use case.
      #checkov:skip=CKV_AWS_158: Logs encryption with CMK not required for this project
      CodeUri: ./
      Handler: ./todos.deleteTodoHandler
      Runtime: nodejs20.x
      Timeout: 10
      Environment:
        Variables:
          TODOS_TABLE_NAME: !Ref TodosTable
      KmsKeyArn: !GetAtt KMSKeyForDBandLogs.Arn # Use the KMS key for encryption
      Role: !GetAtt LambdaExecutionRole.Arn # Assign the explicit IAM role
      Events:
        DeleteTodoApi:
          Type: Api
          Properties:
            Path: /todos/{id}
            Method: delete
            RestApiId: !Ref TodoApi

  # --- S3 Bucket for Static Frontend Hosting ---
  LoggingBucket:
    Type: AWS::S3::Bucket
    Properties:        
      # checkov:skip=CKV_AWS_18: This S3 bucket has access logging disabled, but it is not a security risk in this context.
      BucketName: !Sub ${FrontendBucketName}-logs # Unique bucket name for logging
      VersioningConfiguration:
        Status: Enabled # Enable versioning for the logging bucket
      OwnershipControls:
        Rules:
          - ObjectOwnership: ObjectWriter # Enforce bucket owner full control
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true # Block public ACLs
        IgnorePublicAcls: true # Ignore public ACLs
        BlockPublicPolicy: true # Block public policies
        RestrictPublicBuckets: true # Restrict public buckets
 
  # Bucket Policy to allow CloudFront service to write logs to this bucket
  LoggingBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref LoggingBucket
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: AllowCloudFrontServicePut
            Effect: Allow
            Principal:
              Service: delivery.logs.amazonaws.com
            Action: s3:PutObject
            Resource: !Sub "${LoggingBucket.Arn}/cloudfront-logs/*"
            Condition:
              StringEquals:
                "AWS:SourceAccount": !Ref AWS::AccountId

  FrontendBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Ref FrontendBucketName
      LoggingConfiguration:
        DestinationBucketName: !Ref LoggingBucket # Use the logging bucket for storing access logs
        LogFilePrefix: logs/ # Prefix for log files
      VersioningConfiguration:
        Status: Enabled # Enable versioning for the frontend bucket
      WebsiteConfiguration:
        IndexDocument: index.html
        ErrorDocument: index.html # For single-page applications, route all errors to index.html
      # Public access block configuration to prevent public access to the bucket
      PublicAccessBlockConfiguration:
          BlockPublicAcls: true # Block public ACLs
          IgnorePublicAcls: true # Ignore public ACLs
          BlockPublicPolicy: true # Block public policies
          RestrictPublicBuckets: true # Restrict public buckets
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders:
              - '*'
            AllowedMethods:
              - GET
              - HEAD
              - POST
              - PUT
              - DELETE
            AllowedOrigins:
              - '*' # Allow all origins for CORS
            ExposedHeaders:
              - ETag
            MaxAge: 3000

  # Bucket Policy to allow CloudFront OAI access and public read for website content
  FrontendBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref FrontendBucket
      # This policy allows CloudFront to access the S3 bucket and also allows public read access for the website.
      PolicyDocument:
        Statement:
          - Sid: CloudFrontOaiAccess
            Effect: Allow
            Principal:
              AWS: !Sub arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity
                ${CloudFrontOriginAccessIdentity}
            Action:
              - s3:GetObject
            Resource: !Join
              - ''
              - - 'arn:aws:s3:::'
                - !Ref FrontendBucket
                - /*

  # --- CloudFront Origin Access Identity (OAI) ---
  # This identity is used by CloudFront to access your S3 bucket,
  # ensuring that the S3 bucket does NOT need to be publicly readable directly.
  CloudFrontOriginAccessIdentity:
    Type: AWS::CloudFront::CloudFrontOriginAccessIdentity
    Properties:
      CloudFrontOriginAccessIdentityConfig:
        Comment: OAI for S3 Frontend Bucket

  # --- Amazon CloudFront Distribution ---
  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Comment: CloudFront distribution for Serverless To-Do App Frontend
        Enabled: true
        WebACLId: !GetAtt WebACL.Arn 
        Logging:
          Bucket: !GetAtt LoggingBucket.DomainName
          IncludeCookies: false # Do not log cookies
          Prefix: cloudfront-logs/ # Prefix for log files
        DefaultCacheBehavior:
          TargetOriginId: S3Origin # Link to the origin defined below
          ViewerProtocolPolicy: redirect-to-https # Redirects HTTP to HTTPS
          AllowedMethods:
            # Allow standard HTTP methods for web content
            - GET
            - HEAD
            - OPTIONS
          CachedMethods:
            - GET
            - HEAD
            - OPTIONS
          ForwardedValues:
            QueryString: true
            Cookies:
              Forward: none
          Compress: true # Enable gzip compression for faster delivery
        Origins:
          - Id: S3Origin
            DomainName: !GetAtt FrontendBucket.RegionalDomainName # Use RegionalDomainName for CloudFront origin
            S3OriginConfig:
              OriginAccessIdentity: !Sub origin-access-identity/cloudfront/${CloudFrontOriginAccessIdentity}
        ViewerCertificate:
          CloudFrontDefaultCertificate: true # Use CloudFront's default SSL certificate
          MinimumProtocolVersion: TLSv1.2_2021 # Use a secure TLS version
        DefaultRootObject: index.html # Serves index.html when root URL is accessed

Outputs:
  # Output the API Gateway endpoint URL after deployment.
  ApiEndPoint:
    Description: API Gateway endpoint URL for Prod stage
    # this will be dynamically generated by SAM during deployment
    # The ServerlessRestApi is a logical ID generated by SAM for the API Gateway.
    # This uses the !Sub intrinsic function to substitute the API ID and region into the URL.
    Value: !Sub https://${TodoApi}.execute-api.${AWS::Region}.amazonaws.com/Prod

  # Output the Cognito User Pool ID and Client ID for frontend configuration.
  UserPoolId:
    Description: Cognito User Pool ID
    Value: !Ref CognitoUserPool

  UserPoolClientId:
    Description: Cognito User Pool Client ID
    Value: !Ref CognitoUserPoolClient

  # Output the CloudFront Distribution URL (your primary access point for the frontend)
  CloudFrontDistributionURL:
    Description: URL of the CloudFront distribution for the static frontend
    Value: !GetAtt CloudFrontDistribution.DomainName
  
  # Output the S3 bucket name for the static frontend.
  FrontendBucketName:
    Description: Name of the S3 bucket hosting the static frontend
    Value: !Ref FrontendBucket
  
  # Output the CloudFront Distribution ID for invalidation purposes.
  CloudFrontDistributionId:
    Description: CloudFront Distribution ID for the static frontend
    Value: !Ref CloudFrontDistribution